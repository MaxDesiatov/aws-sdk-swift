// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension RDSDataService {

    public struct ColumnMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arrayBaseColumnType", required: false, type: .integer), 
            AWSShapeMember(label: "isAutoIncrement", required: false, type: .boolean), 
            AWSShapeMember(label: "isCaseSensitive", required: false, type: .boolean), 
            AWSShapeMember(label: "isCurrency", required: false, type: .boolean), 
            AWSShapeMember(label: "isSigned", required: false, type: .boolean), 
            AWSShapeMember(label: "label", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "nullable", required: false, type: .integer), 
            AWSShapeMember(label: "precision", required: false, type: .integer), 
            AWSShapeMember(label: "scale", required: false, type: .integer), 
            AWSShapeMember(label: "schemaName", required: false, type: .string), 
            AWSShapeMember(label: "tableName", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .integer), 
            AWSShapeMember(label: "typeName", required: false, type: .string)
        ]
        /// Homogenous array base SQL type from java.sql.Types.
        public let arrayBaseColumnType: Int32?
        /// Whether the designated column is automatically numbered
        public let isAutoIncrement: Bool?
        /// Whether values in the designated column's case matters
        public let isCaseSensitive: Bool?
        /// Whether values in the designated column is a cash value
        public let isCurrency: Bool?
        /// Whether values in the designated column are signed numbers
        public let isSigned: Bool?
        /// Usually specified by the SQL AS. If not specified, return column name.
        public let label: String?
        /// Name of the column.
        public let name: String?
        /// Indicates the nullability of values in the designated column. One of columnNoNulls (0), columnNullable (1), columnNullableUnknown (2)
        public let nullable: Int32?
        /// Get the designated column's specified column size.For numeric data, this is the maximum precision.  For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype, this is the length in bytes. 0 is returned for data types where the column size is not applicable.
        public let precision: Int32?
        /// Designated column's number of digits to right of the decimal point. 0 is returned for data types where the scale is not applicable.
        public let scale: Int32?
        /// Designated column's table's schema
        public let schemaName: String?
        /// Designated column's table name
        public let tableName: String?
        /// SQL type from java.sql.Types.
        public let `type`: Int32?
        /// Database-specific type name.
        public let typeName: String?

        public init(arrayBaseColumnType: Int32? = nil, isAutoIncrement: Bool? = nil, isCaseSensitive: Bool? = nil, isCurrency: Bool? = nil, isSigned: Bool? = nil, label: String? = nil, name: String? = nil, nullable: Int32? = nil, precision: Int32? = nil, scale: Int32? = nil, schemaName: String? = nil, tableName: String? = nil, type: Int32? = nil, typeName: String? = nil) {
            self.arrayBaseColumnType = arrayBaseColumnType
            self.isAutoIncrement = isAutoIncrement
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.`type` = `type`
            self.typeName = typeName
        }

        private enum CodingKeys: String, CodingKey {
            case arrayBaseColumnType = "arrayBaseColumnType"
            case isAutoIncrement = "isAutoIncrement"
            case isCaseSensitive = "isCaseSensitive"
            case isCurrency = "isCurrency"
            case isSigned = "isSigned"
            case label = "label"
            case name = "name"
            case nullable = "nullable"
            case precision = "precision"
            case scale = "scale"
            case schemaName = "schemaName"
            case tableName = "tableName"
            case `type` = "type"
            case typeName = "typeName"
        }
    }

    public struct ExecuteSqlRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsSecretStoreArn", required: true, type: .string), 
            AWSShapeMember(label: "database", required: false, type: .string), 
            AWSShapeMember(label: "dbClusterOrInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "schema", required: false, type: .string), 
            AWSShapeMember(label: "sqlStatements", required: true, type: .string)
        ]
        /// ARN of the db credentials in AWS Secret Store or the friendly secret name
        public let awsSecretStoreArn: String
        /// Target DB name
        public let database: String?
        /// ARN of the target db cluster or instance
        public let dbClusterOrInstanceArn: String
        /// Target Schema name
        public let schema: String?
        /// SQL statement(s) to be executed. Statements can be chained by using semicolons
        public let sqlStatements: String

        public init(awsSecretStoreArn: String, database: String? = nil, dbClusterOrInstanceArn: String, schema: String? = nil, sqlStatements: String) {
            self.awsSecretStoreArn = awsSecretStoreArn
            self.database = database
            self.dbClusterOrInstanceArn = dbClusterOrInstanceArn
            self.schema = schema
            self.sqlStatements = sqlStatements
        }

        private enum CodingKeys: String, CodingKey {
            case awsSecretStoreArn = "awsSecretStoreArn"
            case database = "database"
            case dbClusterOrInstanceArn = "dbClusterOrInstanceArn"
            case schema = "schema"
            case sqlStatements = "sqlStatements"
        }
    }

    public struct ExecuteSqlResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "sqlStatementResults", required: true, type: .list)
        ]
        /// Results returned by executing the sql statement(s)
        public let sqlStatementResults: [SqlStatementResult]

        public init(sqlStatementResults: [SqlStatementResult]) {
            self.sqlStatementResults = sqlStatementResults
        }

        private enum CodingKeys: String, CodingKey {
            case sqlStatementResults = "sqlStatementResults"
        }
    }

    public struct Record: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "values", required: false, type: .list)
        ]
        /// Record
        public let values: [Value]?

        public init(values: [Value]? = nil) {
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case values = "values"
        }
    }

    public struct ResultFrame: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "records", required: false, type: .list), 
            AWSShapeMember(label: "resultSetMetadata", required: false, type: .structure)
        ]
        /// ResultSet Metadata.
        public let records: [Record]?
        /// ResultSet Metadata.
        public let resultSetMetadata: ResultSetMetadata?

        public init(records: [Record]? = nil, resultSetMetadata: ResultSetMetadata? = nil) {
            self.records = records
            self.resultSetMetadata = resultSetMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case records = "records"
            case resultSetMetadata = "resultSetMetadata"
        }
    }

    public struct ResultSetMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "columnCount", required: false, type: .long), 
            AWSShapeMember(label: "columnMetadata", required: false, type: .list)
        ]
        /// Number of columns
        public let columnCount: Int64?
        /// List of columns and their types
        public let columnMetadata: [ColumnMetadata]?

        public init(columnCount: Int64? = nil, columnMetadata: [ColumnMetadata]? = nil) {
            self.columnCount = columnCount
            self.columnMetadata = columnMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case columnCount = "columnCount"
            case columnMetadata = "columnMetadata"
        }
    }

    public struct SqlStatementResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "numberOfRecordsUpdated", required: false, type: .long), 
            AWSShapeMember(label: "resultFrame", required: false, type: .structure)
        ]
        /// Number of rows updated.
        public let numberOfRecordsUpdated: Int64?
        /// ResultFrame returned by executing the sql statement
        public let resultFrame: ResultFrame?

        public init(numberOfRecordsUpdated: Int64? = nil, resultFrame: ResultFrame? = nil) {
            self.numberOfRecordsUpdated = numberOfRecordsUpdated
            self.resultFrame = resultFrame
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfRecordsUpdated = "numberOfRecordsUpdated"
            case resultFrame = "resultFrame"
        }
    }

    public struct StructValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "attributes", required: false, type: .list)
        ]
        /// Struct or UDT
        public let attributes: [Value]?

        public init(attributes: [Value]? = nil) {
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
        }
    }

    public class Value: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arrayValues", required: false, type: .list), 
            AWSShapeMember(label: "bigIntValue", required: false, type: .long), 
            AWSShapeMember(label: "bitValue", required: false, type: .boolean), 
            AWSShapeMember(label: "blobValue", required: false, type: .blob), 
            AWSShapeMember(label: "doubleValue", required: false, type: .double), 
            AWSShapeMember(label: "intValue", required: false, type: .integer), 
            AWSShapeMember(label: "isNull", required: false, type: .boolean), 
            AWSShapeMember(label: "realValue", required: false, type: .float), 
            AWSShapeMember(label: "stringValue", required: false, type: .string), 
            AWSShapeMember(label: "structValue", required: false, type: .structure)
        ]
        /// Arbitrarily nested arrays
        public let arrayValues: [Value]?
        /// Long value
        public let bigIntValue: Int64?
        /// Bit value
        public let bitValue: Bool?
        /// Blob value
        public let blobValue: Data?
        /// Double value
        public let doubleValue: Double?
        /// Integer value
        public let intValue: Int32?
        /// Is column null
        public let isNull: Bool?
        /// Float value
        public let realValue: Float?
        /// String value
        public let stringValue: String?
        /// Struct or UDT
        public let structValue: StructValue?

        public init(arrayValues: [Value]? = nil, bigIntValue: Int64? = nil, bitValue: Bool? = nil, blobValue: Data? = nil, doubleValue: Double? = nil, intValue: Int32? = nil, isNull: Bool? = nil, realValue: Float? = nil, stringValue: String? = nil, structValue: StructValue? = nil) {
            self.arrayValues = arrayValues
            self.bigIntValue = bigIntValue
            self.bitValue = bitValue
            self.blobValue = blobValue
            self.doubleValue = doubleValue
            self.intValue = intValue
            self.isNull = isNull
            self.realValue = realValue
            self.stringValue = stringValue
            self.structValue = structValue
        }

        private enum CodingKeys: String, CodingKey {
            case arrayValues = "arrayValues"
            case bigIntValue = "bigIntValue"
            case bitValue = "bitValue"
            case blobValue = "blobValue"
            case doubleValue = "doubleValue"
            case intValue = "intValue"
            case isNull = "isNull"
            case realValue = "realValue"
            case stringValue = "stringValue"
            case structValue = "structValue"
        }
    }

}